# MySQL

MySQL是一种**关系型数据库**。

## 引擎

MySQL的默认引擎为**InnoDB**（5.5版之后）。InnoDB是**事务性存储引擎**，也就是说**InnoDB支持事务**。

**MyISAM和InnoDB区别**：MyISAM是MySQL的默认数据库引擎（5.5版本之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是奔溃后无法安全恢复。

MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

## 字符集和校对规则

**字符集**指一种从二进制编码到某类字符符号的映射。

**校对规则**指某种字符集下的排序规则。MySQL每一种字符集都会对应一系列的校对规则。

## 索引

MySQL索引使用的数据结构主要有**BTree索引**和**哈希索引**。

- 哈希索引底层的数据结构就是**哈希表**，适用于**单条记录查询**；其余情况建议使用BTree索引。

- MySQL的BTree索引的数据结构是**B+Tree**。

**B+Tree在InnoDB引擎的实现**：索引文件和数据文件是分离的，其表数据文件本身按照B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“**聚簇索引**”。其余索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址。

在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。**因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂**。

## 事务

事务是逻辑上的**一组操作**，**要么都执行，要么都不执行**。

四大特性：

1. **原子性（Atomicity）**：事务是最小的执行单位，不允许分割。
2. **一致性（Consistency）**：数据库在事务执行前后都保持一致性状态。
3. **隔离性（Isolation）**：一个事务所做的修改在最终提交之前，对其它事务不可见。
4. **持久性（Durability）**：事务对数据库中数据的改变是持久的。

## 并发一致性问题

在并发情况下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

- 丢失修改

  T1和T2两个事务都对一个数据库进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。

- 读脏数据

  T1修改一个数据，T2随后读取了这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据。

- 不可重复度

  T2读取了一个数据，T1对该数据做了修改。如果T2再次读取这个数据，读取结果不一致。

## 封锁

通过封锁机制来解决并发一致性问题。

### 封锁粒度

MySQL中提供了两种封锁粒度：**行级锁**以及**表级锁**。

在选择封锁粒度是，需要在**锁开销**和**并发程度**之间做一个平衡。

- 锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。
- 加锁需要消耗资源。封锁粒度越小，系统开销就越大。

### 封锁类型

#### 读写锁

- 排它锁（Exclusive），简写为X锁，又称写锁。
- 共享锁（Shared），简写为S锁，又称读锁。

有以下两个规定：

1. 一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间，其它事务不能对A加任何锁。
2. 一个事务对数据对象A加了S锁，可以对A进行读取操作，但不鞥进行更新操作。加锁期间，其它事务能对A加S锁，但不能加X锁。

锁的兼容性如下图所示：

| ---- |  X   |  S   |
| :--: | :--: | :--: |
|  X   |  ×   |  ×   |
|  S   |  ×   |  √   |

#### 意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

### 封锁协议

- **一级封锁协议**：事务T要修改数据A时必须加X锁，直到T结束才释放锁。

  可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

- **二级封锁协议**：在一级的基础上，要求读取数据A时，必须加S锁。读取完马上释放S锁。

  可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据一级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

- **三级封锁协议**：在二级的基础上，要求读取数据 A 时，必须加 S 锁，直到事务结束了才能释放 S 锁。

  可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读期间数据发生改变。

## 范式

1. 第一范式：属性不可分
2. 第二范式：每个非主属性完全函数依赖于键码
3. 第三范式：非主属性不传递函数依赖于键码。