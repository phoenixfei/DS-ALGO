## Java并发基础

### 进程、线程

**进程**：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。

系统运行一个程序即是一个进程从创建、运行到消亡的过程。

**线程**：一个进程在其执行的过程中可以产生多个线程。

多个线程共享进程的**堆**和**方法区**资源；但每个线程都有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**。

在Java中，当我们启动main函数时，其实就是启动了一个JVM的进程，而main函数所在的线程就是这个进程的一个线程，也称为主线程。

---

为什么**程序计数器**、**虚拟机栈**和**本地方法栈**是线程私有的呢？为什么堆和方法区是线程共享的呢？

**程序计数器**的作用：

1. 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制。如，顺序执行、选择、循环、异常处理等。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来，能回到准确运行的位置。

所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

**虚拟机栈**：每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。

**本地方法栈**：和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在HotSpot虚拟机中和Java虚拟机栈合二为一。

所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

---

**堆**和**方法区**：所有线程共享的资源。

- 堆是进程中最大的一块内存，主要用于存放新创建的对象（所有对象都在这里分配内存）；
- 方法区主要用于存放已被加载的类信息、常亮、静态变量、即时编译器编译后的代码等数据。

---

**并发**：同一时间段，多个任务都在执行（单位时间内，不一定同时执行）

**并行**：单位时间内，多个任务同时执行。

---

1. 为什么要使用多线程？

利用好多线程机制可以提高系统整体的并发能力及性能。

- 单核时代，提高CPU和IO设备的综合利用率。当一个线程执行CPU计算时，另一个线程可以进行IO操作。
- 多核时代，提高CPU的利用率。例如，一个复杂的任务，单线程只有一个CPU参与运算；多线程可以让多个CPU核心被利用。

2. 多线程带来的问题？

比如：内存泄漏、上下文切换、死锁以及受限于硬件和软件的资源闲置问题。

3. 什么是**上下文切换**？

一个CPU核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU采取的策略是：为每个线程分配时间片并轮转的形式。

当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。

### 线程死锁

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

如下图所示，线程A持有资源2，线程B持有资源1，它们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。

![68747470756e634242254539253934253831312e706e67](assets/68747470756e634242254539253934253831312e706e67.png)

---

**线程死锁条件及避免死锁**

死锁条件（必须具备四个必要条件）：

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

避免死锁（破坏其中一个即可）：

1. 互斥条件：无法破坏，因为锁本身目的是让他们互斥（临界资源需要互斥访问）
2. 破坏请求与保持条件：一次性申请所有资源
3. 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放自己占用的资源
4. 破坏循环等待条件：靠顺序申请来预防。按某一顺序申请资源，释放资源则反序释放。

### synchronized关键字

synchronized关键字解决多个线程之间访问资源的同步性。synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。‘

synchronized关键字最主要的**三种使用方式**：

- **修饰实例方法**：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁

- **修饰静态方法**：也就是给当前类加锁，会作用于类的所有对象实例。

  如果一个线程A调用了一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的。因为，访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁。

- **修饰代码块**：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

**总结**：

- synchronized关键字加到static静态方法和synchronized(class)代码块上都是给Class类上锁。
- synchronized关键字加到实例方法上是给对象加锁。
- 尽量不要使用synchronized(String a)。因为JVM中，字符串常量池具有缓存功能。

---

一道常见的关于synchronized关键字具体使用的[面试题](https://blog.csdn.net/kaixuanfeng2012/article/details/82790586)：**双重校验锁实现对象单例（线程安全）**

采用volatile关键字修饰：禁止JVM的指令重排，保证在多线程环境下也能正常运行。

```java
public class Singleton{
    
    private volatile static Singleton uniqueInstance;
    
    private Singleton(){}
    
    public static Singleton getUniqueInstance(){
        if(uniqueInstance == null){
            synchronized(Singleton.class){
                if(uniqueInstance == null){
                    uniqueInstance = new Singelton();
                }
            }
        }
        return uniqueInstance;
    }
}
```























