# Java集合

## List、Set、Map

List：存储一组不唯一、有序的对象；

Set：不允许重复的结合。无序（插入顺序）。

Map：使用键值对存储。两个key可以引用相同的对象，但是key不能重复。

### List

典型集合**ArrayList**与**LinkedList**的区别：

- 都是线程不同步，也就是线程不安全的。
- 底层数据结构。ArrayList是Object数组；LinkedList的双向链表（JDK1.6之前为循环链表）。
- 由于底层数据结构的不同，ArrayList支持随机访问（RandomAccess），但插入和删除（指定位置）的时间复杂度受元素位置的影响。LinkedList则相反。
- 内存空间占用。ArrayList的空间浪费主要体现在，list列表的结尾会预留一定的容量；ArrayList主要体现在每一个元素都要消耗比ArrayList更多的空间（存放后继和前驱指针）。

快速随机访问就是可以通过元素的序号获取元素的对象（对应`get(int index)`方法）。

**遍历方式的选取：**

- 实现了RandomAccess接口的List（ArrayList），优先选择普通for循环，其次foreach。
- 未实现RandomAccess接口的List（LinkedList），优先选择iterator（foreach底层也是通过iterator实现，大size的数据，千万别使用for i循环）。

**Vector**是**线程同步**的ArrayList。

**这里补充一点比较重要，但是容易被忽视掉的知识点：**

- Java中的 `length `属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.
- Java中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.
- Java中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!

### Set

**HashSet**（无序、唯一）：基于HashMap实现，底层采用HashMap来保存元素。

**TreeSet**（有序、唯一）：红黑树（自平衡的排序二叉树）。

**HashSet如何判断重复**：

首先判断hashcode，再判断equals方法。

**hashCode（）与equals（）的相关规定：**

1. 如果两个对象相等，则hashcode一定也是相同的
2. 两个对象相等,对两个equals方法返回true
3. 两个对象有相同的hashcode值，它们也不一定是相等的
4. 综上，equals方法被覆盖过，则hashCode方法也必须被覆盖
5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。

**==与equals的区别**

1. ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同
2. ==是指对内存地址进行比较 equals()是对字符串的内容进行比较
3. ==指引用是否相同 equals()指的是值是否相同

### Map

**HashMap：**JDK1.8之前HashMap是由数组+链表组成的，数组是HashMap的主体，链表则是为了解决哈希冲突而存在的（”拉链法“解决冲突）。JDK1.8以后再解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。

所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

**TreeMap：**红黑树（自平衡的排序二叉树）。

TreeMap能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器。当使用Iterator遍历TreeMap时，得到的记录是排过序的。在使用TreeMap时，key必须实现Comparable接口，或者在构造TreeMap时传入自定义的Comparator，否则在运行时抛出ClassCastException类型的异常。

### Collections与Arrays

Collections是一个操作集合的工具类，常用方法有：

```java
// 对list集合排序
sort(list);
sort(list,comparator)；
// 对list进行二分查找，二分查找必须集合有序
int binarySearch(list,key);
int binarySearch(list,key,Comparator);
// 最大值、最小值
T max(list);
T min(list)
// 对list集合进行反转
reverse(list);    
```

Arrays是操作数组对象的工具类。

常用方法有：

- *二分查找*
- *数组排序*
- *将数组变成集合asList*
- *将数组变成字符串toString*
- *复制数组copyOf*
- *复制部分数组copyOfRange*
- *比较两个数组是否相同equals*

## 队列、栈

## [优先级队列](https://my.oschina.net/leejun2005/blog/135085)（PriorityQueue）

PriorityQueue是一种基于**优先级堆**的极大优先级队列。

优先级队列是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素。

如果不提供Comparator的话，优先级队列元素默认按自然顺序排列，也就是数字默认是小的在队列头，字符串则按字典序排列。

优先级队列不允许null元素，同时也不允许插入不可比较的对象（导致ClassCastException）。

**注意：**

- 优先级队列是用数组实现，数组大小可以动态增加，容量无限。
- 此实现是不同步的，是线程不安全的。PriorityBlockingQueue是线程安全的。
- 方法iterator()中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。原因可参考大顶堆、小顶堆的内部实现。
- 此类实现了Collection和Iterator接口的所有可选方法。

```java
// 未指定Comparator，按插入元素自然顺序排序
public static void testPriorityQueue() {
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    pq.add(1);pq.add(2);pq.add(4);pq.add(3);
    while (!pq.isEmpty()) {
        System.out.print(pq.poll()+"\t"); // 1	2	3	4
    }
}

// 指定Comparator
public static void testPriorityQueue2() {
    // 利用匿名内部内指定Comparator
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>(){
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2.compareTo(o1);
        }

    });
    pq.add(1);pq.add(2);pq.add(4);pq.add(3);
    while (!pq.isEmpty()) {
        System.out.print(pq.poll()+"\t"); // 4	3	2	1
    }
}
```



## LeetCode例题

### HashSet

Java中的HashSet用于存储一个集合，可以查找元素是否在集合中。

```java
// https://leetcode.com/problems/longest-consecutive-sequence/
public int longestConsecutive(int[] nums) {
    Set<Integer> num_set = new HashSet<Integer>();
    for (int num : nums) {
        num_set.add(num);
    }
    int longestStreak = 0;
    for (int num : num_set) {
        if (!num_set.contains(num - 1)) {
            int currentNum = num;
            int currentStreak = 1;

            while (num_set.contains(currentNum + 1)) {
                currentNum += 1;
                currentStreak += 1;
            }

            longestStreak = Math.max(longestStreak, currentStreak);
        }
    }
    return longestStreak;
}
```

### HashMap

Java中的HashMap主要用于映射关系，从而把两个元素联系起来。HashMap也可以用来对元素进行计数统计，此时键为元素，值为计数。

```java
// https://leetcode.com/problems/two-sum/
public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> indexForNum = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (indexForNum.containsKey(target - nums[i])) {
            return new int[]{indexForNum.get(target - nums[i]), i};
        } else {
            indexForNum.put(nums[i], i);
        }
    }
    return null;
}
```

