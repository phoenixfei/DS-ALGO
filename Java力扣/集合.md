# Java集合

## 哈希表

哈希表使用O(N)空间复杂度存储数据，以O(1)时间复杂度解决问题



## [优先级队列](https://my.oschina.net/leejun2005/blog/135085)（PriorityQueue）

PriorityQueue是一种基于**优先级堆**的极大优先级队列。

优先级队列是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素。

如果不提供Comparator的话，优先级队列元素默认按自然顺序排列，也就是数字默认是小的在队列头，字符串则按字典序排列。

优先级队列不允许null元素，同时也不允许插入不可比较的对象（导致ClassCastException）。

**注意：**

- 优先级队列是用数组实现，数组大小可以动态增加，容量无限。
- 此实现是不同步的，是线程不安全的。PriorityBlockingQueue是线程安全的。
- 方法iterator()中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。原因可参考大顶堆、小顶堆的内部实现。
- 此类实现了Collection和Iterator接口的所有可选方法。

```java
// 未指定Comparator，按插入元素自然顺序排序
public static void testPriorityQueue() {
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    pq.add(1);pq.add(2);pq.add(4);pq.add(3);
    while (!pq.isEmpty()) {
        System.out.print(pq.poll()+"\t"); // 1	2	3	4
    }
}

// 指定Comparator
public static void testPriorityQueue2() {
    // 利用匿名内部内指定Comparator
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>(){
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2.compareTo(o1);
        }

    });
    pq.add(1);pq.add(2);pq.add(4);pq.add(3);
    while (!pq.isEmpty()) {
        System.out.print(pq.poll()+"\t"); // 4	3	2	1
    }
}
```



## LeetCode例题

### HashSet

Java中的HashSet用于存储一个集合，可以查找元素是否在集合中。

```java
// https://leetcode.com/problems/longest-consecutive-sequence/
public int longestConsecutive(int[] nums) {
    Set<Integer> num_set = new HashSet<Integer>();
    for (int num : nums) {
        num_set.add(num);
    }
    int longestStreak = 0;
    for (int num : num_set) {
        if (!num_set.contains(num - 1)) {
            int currentNum = num;
            int currentStreak = 1;

            while (num_set.contains(currentNum + 1)) {
                currentNum += 1;
                currentStreak += 1;
            }

            longestStreak = Math.max(longestStreak, currentStreak);
        }
    }
    return longestStreak;
}
```

### HashMap

Java中的HashMap主要用于映射关系，从而把两个元素联系起来。HashMap也可以用来对元素进行计数统计，此时键为元素，值为计数。

```java
// https://leetcode.com/problems/two-sum/
public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> indexForNum = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (indexForNum.containsKey(target - nums[i])) {
            return new int[]{indexForNum.get(target - nums[i]), i};
        } else {
            indexForNum.put(nums[i], i);
        }
    }
    return null;
}
```

